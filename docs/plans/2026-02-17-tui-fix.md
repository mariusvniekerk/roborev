# TUI-Triggered Fix via Background Worktrees

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Allow users to trigger `roborev fix` from the TUI, running agents in isolated background worktrees and applying patches when ready.

**Architecture:** New `fix` job type runs in daemon worker pool using temporary worktrees (same pattern as `refine.go`). Agent produces a patch stored in DB. TUI gets a new Tasks view to monitor fix jobs and apply/rebase patches to the working tree.

**Tech Stack:** Go, SQLite, Bubble Tea TUI, git worktrees

---

## Phase 1: Storage Layer - New `fix` Job Type and `patch` Column

### Task 1: Add `JobTypeFix` constant and `parent_job_id`/`patch` columns

**Files:**
- Modify: `internal/storage/models.go:37-43` (add JobTypeFix constant)
- Modify: `internal/storage/models.go:45-80` (add ParentJobID, Patch fields to ReviewJob)
- Modify: `internal/storage/models.go:117-122` (update IsPromptJob to include fix)
- Modify: `internal/storage/db.go` (add migration for new columns)

**Step 1: Add the new constant and struct fields**

In `internal/storage/models.go`, add to the JobType constants block:

```go
JobTypeFix     = "fix"     // Background fix using worktree
```

Add to ReviewJob struct (after OutputPrefix field, before sync fields):

```go
ParentJobID *int64  `json:"parent_job_id,omitempty"` // Job being fixed (for fix jobs)
Patch       *string `json:"patch,omitempty"`          // Generated diff patch (for completed fix jobs)
```

Update `IsPromptJob()` to include fix jobs:

```go
func (j ReviewJob) IsPromptJob() bool {
	return j.JobType == JobTypeTask || j.JobType == JobTypeCompact || j.JobType == JobTypeFix
}
```

Add a helper:

```go
func (j ReviewJob) IsFixJob() bool {
	return j.JobType == JobTypeFix
}
```

**Step 2: Add database migration**

In `internal/storage/db.go`, add at the end of `migrate()` before `return nil`:

```go
// Migration: add parent_job_id column to review_jobs if missing
err = db.QueryRow(`SELECT COUNT(*) FROM pragma_table_info('review_jobs') WHERE name = 'parent_job_id'`).Scan(&count)
if err != nil {
    return fmt.Errorf("check parent_job_id column: %w", err)
}
if count == 0 {
    _, err = db.Exec(`ALTER TABLE review_jobs ADD COLUMN parent_job_id INTEGER`)
    if err != nil {
        return fmt.Errorf("add parent_job_id column: %w", err)
    }
}

// Migration: add patch column to review_jobs if missing
err = db.QueryRow(`SELECT COUNT(*) FROM pragma_table_info('review_jobs') WHERE name = 'patch'`).Scan(&count)
if err != nil {
    return fmt.Errorf("check patch column: %w", err)
}
if count == 0 {
    _, err = db.Exec(`ALTER TABLE review_jobs ADD COLUMN patch TEXT`)
    if err != nil {
        return fmt.Errorf("add patch column: %w", err)
    }
}
```

**Step 3: Update EnqueueOpts and EnqueueJob**

In `internal/storage/jobs.go`, add `ParentJobID` to `EnqueueOpts`:

```go
ParentJobID int64  // Parent job being fixed (for fix jobs)
```

Update the INSERT in `EnqueueJob` to include `parent_job_id`.

**Step 4: Add SaveJobPatch helper**

In `internal/storage/jobs.go`, add:

```go
func (db *DB) SaveJobPatch(jobID int64, patch string) error {
    _, err := db.Exec(`UPDATE review_jobs SET patch = ? WHERE id = ?`, patch, jobID)
    return err
}
```

**Step 5: Update job scan functions to include new columns**

Grep for the SELECT queries that read review_jobs and add `parent_job_id` and `patch` to the column lists and scan targets.

**Step 6: Run tests**

```bash
go test ./internal/storage/... -v -count=1
go vet ./...
```

**Step 7: Commit**

```bash
git add -A && git commit -m "feat: add fix job type with parent_job_id and patch columns"
```

---

## Phase 2: Worker Pool - Fix Job Processing with Worktrees

### Task 2: Extract worktree helpers from refine.go to shared package

**Files:**
- Create: `internal/worktree/worktree.go` (shared worktree helpers)
- Modify: `cmd/roborev/refine.go` (use shared helpers)

**Step 1: Create `internal/worktree/worktree.go`**

Extract `createTempWorktree` from `cmd/roborev/refine.go:1002-1054` into a shared package. The function signature stays the same:

```go
package worktree

func Create(repoPath string) (worktreeDir string, cleanup func(), err error)
```

Also extract the diff-capture logic (getting the patch from a worktree):

```go
func CapturePatch(worktreeDir string) (string, error)
```

This runs `git add -A` then `git diff --cached --binary` in the worktree and returns the patch string.

**Step 2: Update refine.go to use shared helpers**

Replace `createTempWorktree` calls with `worktree.Create`.

**Step 3: Run tests**

```bash
go build ./...
go test ./... -v -count=1
```

**Step 4: Commit**

```bash
git add -A && git commit -m "refactor: extract worktree helpers to internal/worktree package"
```

### Task 3: Add fix job processing to worker pool

**Files:**
- Modify: `internal/daemon/worker.go:267-310` (add fix job handling in processJob)

**Step 1: Add fix job processing branch**

In `processJob()`, after the prompt-building if/else chain (around line 305), add a new branch for fix jobs. The fix job flow is:

1. Use the pre-stored prompt (fix jobs are prompt jobs via `IsPromptJob()`)
2. Create a temporary worktree via `worktree.Create(job.RepoPath)`
3. Run the agent with `agentic=true` in the worktree directory (pass worktree path instead of repo path to `a.Review()`)
4. Capture the patch via `worktree.CapturePatch(worktreeDir)`
5. Store the patch via `db.SaveJobPatch(job.ID, patch)`
6. Clean up the worktree
7. Store the agent output as a review (existing `CompleteJob` flow)

The key change is in the `a.Review()` call â€” for fix jobs, pass the worktree path as the repo path:

```go
reviewRepoPath := job.RepoPath
if job.IsFixJob() {
    wtDir, wtCleanup, err := worktree.Create(job.RepoPath)
    if err != nil {
        wp.failOrRetry(workerID, job, job.Agent, fmt.Sprintf("create worktree: %v", err))
        return
    }
    defer wtCleanup()
    reviewRepoPath = wtDir
}

output, err := a.Review(ctx, reviewRepoPath, job.GitRef, reviewPrompt, outputWriter)

// After agent completes, capture patch for fix jobs
if job.IsFixJob() {
    patch, patchErr := worktree.CapturePatch(wtDir)
    if patchErr != nil {
        log.Printf("[%s] Warning: failed to capture patch for fix job %d: %v", workerID, job.ID, patchErr)
    } else if patch != "" {
        if err := wp.db.SaveJobPatch(job.ID, patch); err != nil {
            log.Printf("[%s] Warning: failed to save patch for fix job %d: %v", workerID, job.ID, err)
        }
    }
}
```

**Step 2: Run tests**

```bash
go build ./...
go test ./internal/daemon/... -v -count=1
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add fix job processing with worktree isolation in worker pool"
```

---

## Phase 3: API Endpoint for Fix Jobs

### Task 4: Add fix-specific API endpoint

**Files:**
- Modify: `internal/daemon/server.go` (add `/api/job/fix` endpoint and `/api/job/patch` endpoint)

**Step 1: Add the fix endpoint**

Register new routes in `NewServer`:

```go
mux.HandleFunc("/api/job/fix", s.handleFixJob)
mux.HandleFunc("/api/job/patch", s.handleGetPatch)
```

`handleFixJob` accepts POST with:

```go
type FixJobRequest struct {
    ParentJobID int64  `json:"parent_job_id"`
    Prompt      string `json:"prompt,omitempty"` // Optional custom prompt override
}
```

The handler:
1. Fetches the parent job by ID
2. Fetches the review for the parent job
3. Builds the fix prompt using `prompt.BuildAddressPrompt` (or uses custom prompt if provided)
4. Enqueues a new fix job with `JobType: "fix"`, `Agentic: true`, `ParentJobID: parentJobID`
5. Returns the new job

`handleGetPatch` accepts GET with `?job_id=N` and returns the patch text.

**Step 2: Run tests**

```bash
go build ./...
go test ./internal/daemon/... -v -count=1
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add /api/job/fix and /api/job/patch endpoints"
```

---

## Phase 4: TUI - Tasks View and Fix Trigger

### Task 5: Add `tuiViewTasks` and task-related TUI state

**Files:**
- Modify: `cmd/roborev/tui.go` (add tuiViewTasks constant, task state fields to tuiModel)

**Step 1: Add the view constant**

```go
const (
    tuiViewQueue tuiView = iota
    tuiViewReview
    tuiViewPrompt
    tuiViewFilter
    tuiViewComment
    tuiViewCommitMsg
    tuiViewHelp
    tuiViewTail
    tuiViewTasks      // NEW: background fix tasks view
    tuiViewFixPrompt  // NEW: fix prompt confirmation modal
)
```

**Step 2: Add task state fields to tuiModel**

```go
// Fix task state
fixJobs         []storage.ReviewJob // Fix jobs for tasks view
fixSelectedIdx  int
fixPromptText   string  // Editable fix prompt
fixPromptJobID  int64   // Parent job ID for fix prompt
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add tuiViewTasks and fix state fields to TUI model"
```

### Task 6: Add 'F' keybinding to trigger fix from review view

**Files:**
- Modify: `cmd/roborev/tui_handlers.go` (add 'F' key handler, fix prompt modal handler)

**Step 1: Add 'F' to handleGlobalKey**

In `handleGlobalKey`, add:

```go
case "F":
    return m.handleFixKey()
```

`handleFixKey` checks if a review is selected and has a failing verdict, then opens the fix prompt confirmation modal (`tuiViewFixPrompt`) with a pre-filled prompt.

**Step 2: Add handleFixPromptKey for the modal**

Add the modal to `handleKeyMsg` dispatch:

```go
case tuiViewFixPrompt:
    return m.handleFixPromptKey(msg)
```

The modal shows the fix prompt (editable) and on `enter` calls the fix API endpoint, then switches to the tasks view.

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add F keybinding to trigger fix from TUI review view"
```

### Task 7: Add Tasks view rendering and key handling

**Files:**
- Modify: `cmd/roborev/tui_helpers.go` (add tasks view rendering)
- Modify: `cmd/roborev/tui_handlers.go` (add tasks view key handling)
- Modify: `cmd/roborev/tui_api.go` (add API calls for fix jobs and patches)

**Step 1: Add 'T' keybinding to toggle queue/tasks view**

In `handleGlobalKey`:

```go
case "T":
    return m.handleToggleTasksKey()
```

This toggles between `tuiViewQueue` and `tuiViewTasks`.

**Step 2: Add tasks view rendering**

The tasks view shows fix jobs with status indicators:
- Queued/running: spinner
- Done: check mark + dry-run apply status (clean/conflict)
- Failed: X mark

**Step 3: Add tasks view key handling**

Keys in tasks view:
- `enter` - View the patch (renders diff in review-like scroll view)
- `A` - Apply patch to working tree
- `t` - Tail live output (reuse existing tail infrastructure)
- `d` - Discard/cancel fix job
- `T` - Toggle back to queue view

**Step 4: Add API calls**

In `tui_api.go`, add:
- `fetchFixJobs()` - GET `/api/jobs?job_type=fix` (or filter client-side)
- `triggerFix(parentJobID, prompt)` - POST `/api/job/fix`
- `fetchPatch(jobID)` - GET `/api/job/patch?job_id=N`

**Step 5: Run tests**

```bash
go build ./...
go test ./cmd/roborev/... -v -count=1
```

**Step 6: Commit**

```bash
git add -A && git commit -m "feat: add Tasks view with fix job monitoring and patch preview"
```

---

## Phase 5: Patch Application and Rebase Flow

### Task 8: Implement patch apply logic in TUI

**Files:**
- Modify: `cmd/roborev/tui_handlers.go` (apply patch handler)

**Step 1: Implement the 'A' key handler**

When user presses 'A' on a completed fix job:

1. Fetch the patch from the API
2. Write patch to a temp file
3. Run `git apply --check <patch>` (dry-run) in the repo
4. If clean: run `git apply <patch>`, stage, commit, enqueue review for new commit, mark parent as addressed
5. If conflict: show rebase prompt (see Task 9)

The apply runs synchronously in the TUI process (same trust model as CLI `roborev fix`).

**Step 2: Run tests**

```bash
go build ./...
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: implement patch apply from TUI tasks view"
```

### Task 9: Implement rebase flow for stale patches

**Files:**
- Modify: `cmd/roborev/tui_handlers.go` (rebase confirmation and re-trigger)

**Step 1: Add rebase confirmation**

When `git apply --check` fails:
1. Show message: "Patch doesn't apply cleanly. Rebase fix? [enter=yes / esc=cancel]"
2. On confirm: POST `/api/job/fix` with a rebase prompt that includes the original patch as context
3. The prompt instructs the agent to adapt the fix to the current HEAD
4. Switch to tasks view showing the new rebase job

The rebase prompt:

```
# Rebase Fix Request

A previous fix was generated but no longer applies cleanly to the current code.

## Original Patch

<patch content>

## Instructions

Adapt the changes from the original patch to work with the current codebase.
The original patch was for a previous version of the code - apply the same
logical changes but adjusted for the current state of the files.
After making changes, verify the code compiles and tests pass, then commit.
```

**Step 2: Add dry-run staleness indicator in tasks view**

When rendering completed fix jobs, run `git apply --check` and show:
- Green check if patch applies cleanly
- Yellow warning if patch has conflicts

Cache the result and refresh when the tasks view is entered.

**Step 3: Run tests**

```bash
go build ./...
```

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: add rebase flow for stale patches in TUI"
```

---

## Phase 6: Help Text and Polish

### Task 10: Update help view and hint bar

**Files:**
- Modify: `cmd/roborev/tui_helpers.go` (update help text, hint bar)

**Step 1: Add fix/tasks keys to help view**

Add to the help text:
- `F` - Fix: trigger background fix for selected review
- `T` - Toggle tasks view (show background fix jobs)
- `A` - Apply patch (in tasks view)

**Step 2: Update hint bar**

Add contextual hints:
- In queue/review view: show `F fix` when a failing review is selected
- In tasks view: show `A apply` when a completed fix is selected, `T queue` to go back

**Step 3: Run full test suite**

```bash
go test ./... -v -count=1
go vet ./...
go fmt ./...
```

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: update TUI help text and hint bar for fix/tasks"
```
